---
layout: post
title: Preparation for Java 8 OCA 1Z0 808 exam
date: '2016-03-03T12:14:00.003+01:00'
author: Monik
tags:
- Programming
- Java
modified_time: '2016-05-27T11:08:11.690+02:00'
thumbnail: https://1.bp.blogspot.com/-MvbdBFZac_8/Vva6untWECI/AAAAAAAACWY/K1q-kn9QhZcYyqCkrfWeikVrWUSMgUKoQ/s72-c/notinitialized.png
blogger_id: tag:blogger.com,1999:blog-5940427300271272994.post-2617148401622069827
blogger_orig_url: http://learningmonik.blogspot.com/2016/03/preparation-for-java-8-oca-1z0-808-exam.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">These are my<b> study notes</b> taken while preparing for<b> Java Oracle Certified Associate</b> exam and reading one of the available study guides (the one with most review stars found somewhere). Reading such study guide is the best way to prepare for the exam, as it actually teaches you things you will need on the exam rather than what you need when you program in Java (which is entirely different than taking an exam, of course). Here I make notes on the stuff I found new, important or surprising.<br /><br />Some background about me - in my programming experience I started at Java 5 by first reading thoughroughly the first two thirds of Thinking in Java (what I didn't read were threading and custom annotations), I recently understood some Java 8 stuff, though this came mostly by learning F# (functional language derived from C#).<br /><br />Very important: please comment if you find an error.<br /><h3 style="text-align: left;">Things that surprised me about the exam</h3><ul style="text-align: left;"><li>when they ask you about <b>compilation errors</b>, they ask you about <b>all of them</b>, not the first one</li><li>when they ask for the "output" they can mean <b>part of the output</b>, it also counts (facepalm). basically <b>each bit of output can be a separate answer </b>- in such case you need to mark them all</li><li>if there is an answer like "<i>an exception is thrown</i>" it still <b>does not mean </b>that some other outputs are not true as well, that will happen before the exception; exception is not exclusive with other answers</li><li>when there are <b>no line numbers </b>in a code snippet assume <b>missing imports do&nbsp;</b>cause compilation errors</li><li><b>public void MyClass() </b>- this is how they may trick you, notice this is <b>NOT a constructor </b>since it has void return type..</li><li><b>StringBuilder str = "bla"; </b>- another way to trick, this <b>does not compile</b></li><li>Vocabulary: "legal" = "valid" = "compiles"</li></ul><div><span style="background-color: #fff2cc;">I am marking in yellow everything that I consider I need to <b>memorize </b>rather than understand or get a feeling for.</span></div><h3 style="text-align: left;">General things that surprised me about Java</h3><div><h4 style="text-align: left;">On the self assesment test (40% correct)</h4></div><ul style="text-align: left;"><li>class/variable name <b>can </b>start with "_"</li><li>"$" is a <b>perfectly valid</b> variable name, or start of one</li><li>same naming rules apply for methods, variables, fields and classes, and the two above are all the weird exceptions (well except other Unicode letters of weird languages) (<b>numbers </b>are also allowed but <b>not as first</b>)</li><li>the, compiler, will, fu**ing, <b>complain about <u>reading</u> any uninitialized <u>LOCAL</u>&nbsp;variable </b>(<b>ALSO PRIMITIVE</b>), but instance variables are ok (if not final)</li></ul><div class="separator" style="clear: both; text-align: center;"><img border="0" src="https://1.bp.blogspot.com/-MvbdBFZac_8/Vva6untWECI/AAAAAAAACWY/K1q-kn9QhZcYyqCkrfWeikVrWUSMgUKoQ/s1600/notinitialized.png" /></div><ul style="text-align: left;"><li>string1 ==string2 will render <b>true </b>but stringBuffer1.toString()==s2 (with same string) will render <b>false</b> - there's something called <b>string pool; </b>also sth like new String("bla") will be always created not taken from string pool</li></ul><div class="separator" style="clear: both; text-align: center;"><img border="0" src="https://1.bp.blogspot.com/-m88rDwlZoSQ/VvbNgWIQbEI/AAAAAAAACXE/JGWTkdQb1WsJEJAWzjtn-nd2N0voy4oIw/s1600/stringpool.png" /></div><ul style="text-align: left;"><li>printing list without .toString() prints only the object ref of course</li><li>int[] array = {3,5}; - this is also how you can initialize an array (along with ..=new int[]{3,5};), but only <b>if it is in same line as declaration</b>!</li><li>it is possible to <b>override </b>a protected method with a <b>public</b>; if the method is not protected but <b>private</b>, there is no compiler error, and the two are <b>completely separate</b>;</li><li>writing super() in public F() {&nbsp;super();... is optional, <b>super(); will be invoked anyway (first)&nbsp;</b>if no super is invoked manually</li><li><span style="background-color: #fff2cc;"><b>java.lang.Error</b>:&nbsp;<i>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should <b>not </b>try to catch.</i></span></li><li><span style="background-color: #fff2cc;"><b>RuntimeException </b>is thrown by both JVM and developer, <b>Error </b>is thrown by JVM, both are <b>not required </b>to be caught</span></li><li>Java has fu**ing <b>GOTO statements </b>- what the hell?!&nbsp;http://www.java-examples.com/java-continue-statement-label-example</li><li>int x = 6, j=8; - almost forgot this <b>multiple assigment syntax; </b>int i, <strike>int </strike>j; - wrong, int i,j; - good</li><li><b>this loop</b>: do {....}while(condition);</li><li><strike>for(int i=0;i&lt;3;){ </strike><b><strike>means same as&nbsp;for(int i=0;i&lt;3;i++)!!!</strike><span style="color: red;"> WRONG</span></b></li><li>there is such class as <b>java.time.LocalDate</b>, with a <b>static method</b>: of(int year, <b>java.time.Month </b>month, int dayOfMonth), which works predicably, throwing&nbsp;DateTimeException if the input is messed up; <b>months numbered from 1</b>.</li></ul><div class="separator" style="clear: both; text-align: center;"><img border="0" height="328" src="https://1.bp.blogspot.com/-z4wf7b6ELoU/Vva-x1VePKI/AAAAAAAACWo/Mj2eTTrmxQUqTzvP0OXBsEQUcNrjPItgQ/s640/localdate.png" width="640" /><a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html" target="_blank">https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html</a></div><div><br /></div><ul style="text-align: left;"><li>in lambda variations - <span style="background-color: #fff2cc;">if {} are used, <b>return </b>must be used</span></li><li><b>Autoboxing</b> (int&lt;-&gt;Integer) works for collections but <b>not </b>for inferring predicates;</li><li>color=color in constructor works of course, except it does nothing, as "this." is missing</li><li>about interface:&nbsp;<b>default method and normal interface method </b>also do not combine well when implementing 2 interfaces with same method signature (compilation error)</li></ul><div><h4 style="text-align: left;">Chapter 1 Java Building Blocks (83% correct on the test)</h4></div><div><ul style="text-align: left;"><li>a <b>method </b>has input <b>parameters</b></li><li><b>/** </b>is <b>Javadoc comment</b>, and /* is normal comment</li><li><span style="background-color: #fff2cc;">the <b>Java process </b>is managed by <b>JVM </b>and within this process the <b>static void main's code&nbsp;</b>is executed; <b>JVM </b>allocates the <b>memory</b>, <b>CPU</b>, <b>file access</b>, etc.</span></li><li>Starting a Java program: <br /><b><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">$ javac com/bla/Zoo.java <br />$ java com.bla.Zoo</span></b><br /><br />where Zoo has static void main of course (<b>JDK required for javac, for java only JRE</b>); if <b>main is missing </b>the <b>process </b>with throw exception; if <b>main is wrong signature </b>the <b>Java </b>will throw <b>exception</b>; <b>args[0] is not the program name </b>but <b>first input arg</b>; if an input arg has <b>a space</b>, <b>wrap it in d-quotes</b>;&nbsp;</li><li>many imports does not slow down the program, compiler figures out what is actually needed</li><li><b>java.lang.*</b> is <b>automatically imported</b></li><li><b>asterisk</b>&nbsp;in package import <b>does not import child packages</b></li><li>if there is class <b>name conflict in 2 imported packages, you get compilation error</b>: <i>The type ... is ambiguous</i>, but it is ok, if you point to one name explicitly (e.g. java.util.Date and java.sql.*); if both are <b>explicit but collide</b>, you get another compilation error: <i>The import ... collides with another import ...</i></li><li>{..} directly in a class is called<span style="background-color: #fff2cc;"> <b>instance initilalizer </b></span>(may be static or not); instance initilalizer is also a <b>code block</b></li><li><span style="background-color: #fff2cc;"><b>order of initialization: fields </b>and <b>instance initializer </b>blocks are run in the order they appear in the file, and constructor at the end</span></li><li>the opposite of <b>primitive type </b>is called <b>reference type</b></li><li>there is <b>eight primitive types: </b><span style="background-color: #fff2cc;">byte (from -128 to 127), short, int, long: 8, 16, 32, 64-bit integral; float, double: 32, 64-bit floating-point(=decimal); char: 16-bit Unicode</span></li><li><b>int num;&nbsp;</b>- and <b>the 32 bits is already allocated </b>by Java</li><li><span style="background-color: #fff2cc;">number formats:&nbsp;<b>octal</b>:<b> </b>starts with 0, e.g. 017, <b>hexadecimal</b>: starts with 0x or 0X, e.g. 0xFF, <b>binary</b>: starts with 0b or 0B, e.g. 0b10</span></li><li>from Java 7 <b>you can add underscores to numbers</b>, to make them easier to read, e.g. 1_000_000, or 1_00_0_000 :P but not at beginning/end/touching the decimal point</li><li>instance variable = field, class variable = static field</li><li><span style="background-color: #fff2cc;"><b>objects </b>are stored on the <b>heap, </b>references may be</span></li><li>System.gc() is only a <b>suggestion </b>to run gc, not an order</li><li><span style="background-color: #fff2cc;">object is eligible for gc <b>also </b>if <b>all references to it have gone out of scope</b></span></li><li>they claim that "<b>Java prevents memory leaks</b>", ok good to remember</li><li>they say also that it is <b>secure </b>because it runs inside JVM</li><li>double values do not have to have .0, e.g. <b>double d = 98;</b> is ok! (it's called <b>upcasting</b>), same for <b>float</b>!</li><li>even though Java 8 has functional stuff, it's stil an <b>OO language</b></li></ul><div><h4 style="text-align: left;">Chapter 2 Operators and Statements (70% correct on the test)</h4></div></div><div><ul style="text-align: left;"><li>three types of operators: <b>unary</b>, <b>binary</b>, <b>ternary</b>, depending to how many operands they can be applied (1, 2, or 3)</li><li>order of <b>operator precedence </b>(most weird ones are not required for this exam):</li><ul><li><span style="background-color: #fff2cc;">i++, i--</span></li><li><span style="background-color: #fff2cc;">++i, --i</span></li><li><span style="background-color: #fff2cc;">unary +, -, !</span></li><li><span style="background-color: #fff2cc;">*, /, %</span></li><li><span style="background-color: #fff2cc;">+, -</span></li><li><span style="background-color: #fff2cc;">&lt;&lt;, &gt;&gt;, &gt;&gt;&gt; (shift operators)</span></li><li><span style="background-color: #fff2cc;">&lt;, &gt;, &lt;=, &gt;=, instanceof (relational operators)</span></li><li><span style="background-color: #fff2cc;">==, !=</span></li><li><span style="background-color: #fff2cc;">&amp;, ^, | (logical operators)</span></li><li><span style="background-color: #fff2cc;">&amp;&amp;, ||&nbsp;(short circuit logical operators)</span></li><li><span style="background-color: #fff2cc;">ternary a ? b: c</span></li><li><span style="background-color: #fff2cc;">=, +=, -=, *=, /=, %=, &amp;=, ^=, !=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;= (assignment operators)</span></li></ul><li>int t = 11/3 = 3! (floor)</li><li><b>numeric promotion</b></li><ul><li>integer multiplied by double is type double</li><li>numeric promotion occurs actually before the operation, for any operator</li><li><b>short&nbsp;multiplied&nbsp;by short is integer </b>(same for char) for binary operators</li><ul><li>but short t =9, g=2; t *= g; works :) - use of compound assignment, casts automatically <b>after</b></li></ul></ul></ul><blockquote class="tr_bq" style="clear: both; text-align: center;"><img border="0" src="https://3.bp.blogspot.com/-sI_U_czH15k/VvbJAf_AhBI/AAAAAAAACW4/gWHMZ9IWoOEQtDfqIsnnYHpwK0UD8HedQ/s1600/conversion.png" /></blockquote><ul style="text-align: left;"><li>(short)1921222 = 20678 - because <b>overflow </b>happened</li><li>int y = (x=3); - this is <b>correct</b>, and the&nbsp;<b>value </b>is 3;</li><li>the boolean operator ^ means <b>exclusive or</b>!</li><li><b>5 == 5.0 is true </b>(promotion)</li><li><span style="background-color: #fff2cc;">Java statement is <b>complete unit of execution, terminated by semicolon</b></span></li><li><span style="background-color: #fff2cc;">loops, if, are called <b>control flow statements</b></span></li><li><b>watch out for </b>tricky <b>indentation!</b></li><li>the a ? b : c is also doing <b>short circuiting</b></li><li><span style="background-color: #fff2cc;"><b>switch</b>&nbsp;supports: int, byte, short, char, their wrappers, enums and strings </span>(some since Java 7), <b>no long</b>, <b>no boolean</b>! and they must be either constants (e.g. literals) or <b>final</b></li><li>do-while loop <b>guarantees that the statement will be executed at least once, </b>on contrary to the while loop</li><li>the for loop&nbsp;consists of:<span style="background-color: #fff2cc;"> initialization, booleanExpression and updateStatement</span>; <b>initialization </b>and&nbsp;<b>updateStatement&nbsp;</b>may contain <b>mutliple terms</b>, separated by <b>commas </b>(the variables in initialization block have to be of same <b>type</b>,<span style="background-color: #fff2cc;"> variables in the updateStatement <b>may not reference each other</b>)</span></li><li>for (;;) is correct, it's an infinite loop</li><li>the variable declared in the initialization of the loop is <b>scoped only inside the loop</b></li><li>LABEL: is an optional&nbsp;<b>pointer to the head of a statement</b>; does not have to uppercase; can be used after <b>break</b>: break LABEL;or <b>continue</b>:&nbsp;continue LABEL;</li><li><b>continue </b>- finish execution only of current loop;&nbsp;</li><li><span style="background-color: #fff2cc;">there is no <b>continue </b>or <b>break </b>in if!</span></li><li>byte y = (int)short1 + short2 - will <b>not work</b>, bracket missing!</li><li>in <b>do-while </b>- watch out for <b>variable&nbsp;scope</b>!!</li><li>the == operator <b>will not compile </b>if the compared objects are of different type!</li></ul><div class="separator" style="clear: both; text-align: center;"><img border="0" src="https://2.bp.blogspot.com/-7a35UhKEdUE/VvqtkrEvT4I/AAAAAAAACXY/64GYQci049USidfCys4sIz2WobClpHaqg/s1600/incompatibleEquals.png" /></div><div><br /></div><div><h4 style="text-align: left;">Chapter 3 Core Java APIs (69% correct on the test, 23/33 questions)</h4><div><ul><li><span style="background-color: #fff2cc;">API stands for <i>Application Programming Interface</i></span></li></ul></div><div><b>String</b></div><ul style="text-align: left;"><li>System.out.println(1 + 2 + "c"); //outputs "3c" (order of operators)</li><li><b>Strings are immutable </b>(so also <b>final</b>), so doing operations on them always returns a new String</li><li>str.<b>indexOf</b>() - returns first index of occurence, or -1</li><li>str.<b>substring</b>(inclusively, exclusively)</li><li>str.<b>startsWith</b>() and str.<b>endsWith</b>() is case sensitive</li><li><b>String implements CharSequence</b></li><li>str.<b>replace</b>(oldChar, newChar) or oldSequence, newSequence - replaces <b>all occurences</b>!</li><li>StringBuilder=new <b>StringBuilder</b>(10); // initial capacity, default 16</li><li>strBuilder.<b>charAt</b>(), .<b>indexOf</b>(), .<b>length</b>(), .<b>substring</b>(); substring returns a String</li><li>strBuilder.<b>insert</b>(offset, string)</li><li><span style="background-color: #fff2cc;">strBuilder.<b>delete</b>(startInc, endExc), .<b>deleteAt</b>()</span></li><li><span style="background-color: #fff2cc;">strBuilder.<b>reverse</b>()</span></li><li><b>StringBuffer </b>is just an old, thread-safe, slow version of StringBuilder</li><li>System.out.println(stringBuilder); will actually convert it to String</li><li>watch out for stupid spaces in strings, like " bla" :S</li><li>concatenated literals from string pool is a new string and <b>will not be "==" equal </b>to same string from string pool</li></ul><div><b>Array</b></div><ul style="text-align: left;"><li><span style="background-color: #fff2cc;">An <b>array </b>is an area of memory on the <b>heap </b>with space for a designated number of elements</span>; String is implemented as an array</li><li>int[] numbers = new int[3];</li><li>int[] numbers = new int[]{14,12,53};</li><li><span style="background-color: #fff2cc;">int[] numbers = new int{14,12,53};</span></li><li><span style="background-color: #fff2cc;">int [] numbers = new int[3];</span></li><li><span style="background-color: #fff2cc;">int numbers[] = new int[3];</span></li><li>numbers is a <b>reference variable </b>- it <b>points </b>to the array object</li><li>int a[], b; //this is one int array and one int, and is correct!</li><li><span style="background-color: #fff2cc;">[Ljava.lang.String;@160bc7c0 - <b>array </b>of<b> reference type&nbsp;</b>java.lang.String and&nbsp;160bc7c0&nbsp;<b>hash code</b></span></li><li>Arrays of Strings <b>does not allocate space for strings</b>. Only allocates space for references to Strings.</li><li>Arrays will let you cast themselves and put inside it whatever matches the declared type - but gives no shit about runtime errors (ArrayStoreException is thrown on an attempt to store a an object that does not match the <b>initialized </b>type)</li><li>java.util.Arrays.<b>sort</b>(array)</li><li>java.util.Arrays.<b>binarySearch</b>(array, what) - works only for <b>sorted array</b>, for non sorted the result will be random; <b>if the element is not found</b>, this method returns (-1*i)-1, where i is the index where a new element would have to be put to match</li><li><span style="background-color: #fff2cc;">int[] vars4 [], space [][] -<b> this is one 2D and one 3D array</b>!</span></li><li>int[][] differentSize = {{ "{{" }}2},{4,6},{1,2,5,7}}</li><ul><li>int[][] args = new int[4][]; args[0] = new int[5]; args[1] = new int[3];</li></ul><li>char[]c - compiles (no space)</li><li>final int[][] java = new int[][]; - does not <b>compile! </b>cannot have more dimensions before first one is specified (only the first one needs to be specified)!<img border="0" src="https://1.bp.blogspot.com/-44e7d0jNrwo/Vvqw5guPBPI/AAAAAAAACXk/6xxbPMmw1QMtiA3mEaStrNS-JfN9B_KcA/s1600/arrays.png" style="text-align: center;" /></li></ul><ul style="text-align: left;"><ul></ul></ul><div><b>ArrayList</b></div><div><ul style="text-align: left;"><li>new ArrayList(10); //<b>capacity</b></li><li>new ArrayList(<b>anotherList</b>);</li><li><span style="background-color: #fff2cc;"><b>Object&nbsp;</b>arrayList.<b>remove</b>(index);&nbsp;</span></li><li><span style="background-color: #fff2cc;"><b>boolean </b>arrayList.<b>remove</b>(object); //removes <b>first </b>matching</span></li><li>arrayList.<b>removeIf</b>(condition) - new! Java 8!</li><li>ReplaceObject <b>set</b>(index, object)</li><li>.<b>isEmpty</b>(), .<b>clear</b>()</li><li>.<b>contains</b>() - calls <b>equals on elements</b>!</li><li>.<b>equals</b>() - deep comparing</li><li>list.<b>toArray</b>() converts not to ArrayList, but something that <b>does not let you remove</b>() - it's a fixed size version of a list</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-up1TzhXy1r4/Vvqx82jfVUI/AAAAAAAACXs/5NzEiB3XLlYwbsMMYVzioUwmQOUzVXuFA/s1600/toArray.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="263" src="https://2.bp.blogspot.com/-up1TzhXy1r4/Vvqx82jfVUI/AAAAAAAACXs/5NzEiB3XLlYwbsMMYVzioUwmQOUzVXuFA/s640/toArray.png" width="640" /></a></div><div><br /></div><ul style="text-align: left;"><li><span style="background-color: #fff2cc;">Collections.<b>sort</b>(list)</span></li></ul><div><b>Wrappers for Primitives</b>&nbsp;</div></div><div><ul style="text-align: left;"><li><span style="background-color: #fff2cc;"><b>parseInt</b>() returns a <b>primitive</b>, while <b>valueOf</b>() returns a <b>wrapper class</b></span></li><li><b>autoboxing </b>- since Java 5 primitives are <b>automatically </b>converted to wrappers, if needed (except predicates)</li><li>listOfIntegers.<b>add</b>(null) - is legal! but unboxing it into int will cause NullPointerException (as it's not an int), meaning this: <b>int h = listOfIntegers.get(0); </b>btw adding <b>null </b>is no longer called autoboxing</li></ul><div class="separator" style="clear: both; text-align: center;"><img border="0" src="https://2.bp.blogspot.com/-nHh4tDjbLtA/VvqzFwfGdQI/AAAAAAAACX4/yB-cDQ-49lUquDs-RothhnX-6ZmZAvEMA/s1600/autoboxing.png" /></div><div><b><br /></b></div><ul style="text-align: left;"><li>list.<b>remove</b>(2) - will rather treat 2 as index, not object - as int is closer to int than Integer</li></ul><div><b>Dates and Times</b></div></div><div><ul style="text-align: left;"><li>completely different in Java 8, <b>old way is not on the exam </b>(yuppi!!)</li><li>import java.time.*</li><li>time zones are <b>out of scope </b>(yaaay!!)</li><li><b>LocalDate </b>- date without time and timezone, use e.g. for birthday</li><ul><li>LocalDate.now();</li><li>the output <b>depends on the locale </b>where you are, but<b> in exam US format is used</b>: 2015-01-20</li><li><span style="background-color: #fff2cc;">LocalDate.<b>of</b>(2015, Month.JANUARY, 1), same as LocalDate.<b>of</b>(2015, 1, 1)</span></li></ul><li><b>LocalTime </b>- time without timezone and without date</li><ul><li>US output: 12:45:16:245</li><li>LocalDateTime.<b>of</b>(6, 15);</li><li>LocalDateTime.<b>of</b>(6, 15, 30);</li><li>LocalDateTime.<b>of</b>(6, 15, 30, 234); - last one is nanoseconds</li></ul><li><b>LocalDateTime </b>- both date and time but without timezone</li><ul><li>US output: 2015-01-20T12:45:16:245</li><li>Java uses T to separate date from time when converting it to a String</li><li>LocalDateTime.<b>of</b>(2015, Month.JANUARY, 16, 15, 30);</li><li>LocalDateTime.<b>of</b>(date, time);</li></ul><li>Oracle recommends<b> avoiding time zones </b>unless you really need them (yaay!)</li><ul><li>btw, ZonedDateTime is for timezones</li></ul><li>new LocalDate(); - <b>does not compile</b></li><li><b>DateTimeException </b>if the numbers are invalid</li><li>in the past - Date class represented both date and time, always; moths started from 0; actually Calendar was newer way, but still it's old :P and long to use..</li></ul><div><b>Manipulating Date and Time</b></div><ul style="text-align: left;"><li>local<b>Date</b>.<b>plusDays</b>(2); .<b>plusWeeks</b>(), ... - <b>immutable</b>!</li></ul><div class="separator" style="clear: both; text-align: center;"><img border="0" height="172" src="https://2.bp.blogspot.com/-9lUlQTb1wJM/Vvqz1TQ1d-I/AAAAAAAACX8/lOtGhtc1Bos504c6zBoW6eTBBpqSnoNog/s640/immutable.png" width="640" /></div><div><br /></div><ul style="text-align: left;"><li>local<b>Time</b>.<b>minusHours</b>(3);, ... - <b>notice, LocalDate does not operate on hours</b>, and vice versa!</li><li>LocalDate is <b>immutable</b>! - chain those methods</li><li>LocalDate.toEpochDay() - number of days since Jan 1 1970</li><li>LocalDateTime.toEpochTime() - number of seconds</li><li>LocalTime.toEpo... - does not exist!</li><li><b>Period</b>.<b>ofMonths</b>(1); localDate.<b>plus</b>(period); for LocalTime it throws UnsupportedTemporarTypeException</li><li><b>Period</b>.<b>of</b>(1,0,7) - every year and 7 days</li><li>chaining does not take any effect, only last will take effect (compiler warns)</li><li><b>Duration </b>is for hours, minutes and seconds, but it's not on the exam</li><li>localDate.<b>getDayOfWeek</b>(); //MONDAY</li><li>localDate.<b>getDayOfYear</b>(); //30</li></ul><div><b>Formatting Date and Time</b></div><ul style="text-align: left;"><li>java.time.format.<b>DateTimeFormatter</b></li><li>localDate.<b>format</b>(DateTimeFormatter.<b>ISO_LOCAL_DATE</b>); //2020-02-20</li><li>DateTimeFormatter.<b>ISO_LOCAL_TIME </b>//11:12:34</li><li>DateTimeFormatter.<b>ISO_LOCAL_DATE_TIME </b>//2020-02-20T11:12:34</li><li>DateTimeFormatter.<b>ofLocalizedDate</b>(FormatStyle.SHORT).<b>format</b>(dateTime); // 1/20/20 - notice that also has to match, cannot have a time type for localDate (exception)</li><ul><li><b>date formatter </b>can format <b>dateTime</b>, but<b> dateTime formatter </b>cannot format <b>date </b>(exception)</li><li>in other words, formatter is only confused with missing data, it's super fine with too much data ;)</li></ul><li>so can use date.<b>format</b>(formatter) as well as formatter.<b>format</b>(date)</li><li>FormatStyle.<b>SHORT</b>: 1/20/20 11:12 AM</li><li>FormatStyle.<b>MEDIUM</b>: Jan 20, 2020 11:12:34 AM</li><li>DateTimeFormatter.<b>ofPattern</b>("MMMM dd, yyyy, hh:mm"); //January 20, 2020, 11:12 - but remember, also has to match with the formatted type!</li><li>in the past - SimpleDateFormat, same stuff</li><li>be careful, e.g. DateTimeFormatter.<b>ofLocalizedTime </b>outputs only time, even though the formatter is for both dates and times</li></ul><div><b>Parsing Date and Time</b></div></div><div><ul style="text-align: left;"><li>LocalDate.<b>parse</b>(string, formatter);</li><li>LocalDate.<b>parse</b>(string); - uses default</li></ul><div><h4 style="text-align: left;">Chapter 4 Methods And Encapsulation (48% correct, but very very fed up)</h4><ul style="text-align: left;"><li>the difference between <b>default</b> (i.e., when you don't specify any)<b>&nbsp;</b>and <b>protected </b>access - default is only available for the classes in same package, knows nothing about inheritance</li><li><b>optional specifiers</b> are: static, abstract, synchronized (out of scope), native&nbsp;(out of scope), strictfp (out of&nbsp;scope), and they come<b> between </b>the access modifier and the return type</li><li><b>_ and $ are allowed </b>in method name, cannot start with a number though</li><li><b>a vararg must be the last parameter </b>in the parameter list; so only 1 is allowed; if it's absent it means it is an array of length 0; except you have passed <b>null explicitly</b> (works even for primitive types)</li></ul><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-sDweNGNBAZE/VxOgJEd9gaI/AAAAAAAACaU/7g17kxtZ4Gossw7XC1fQsJiqKFAG7jdrQCLcB/s1600/varargs.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-sDweNGNBAZE/VxOgJEd9gaI/AAAAAAAACaU/7g17kxtZ4Gossw7XC1fQsJiqKFAG7jdrQCLcB/s1600/varargs.png" /></a></div><ul style="text-align: left;"><li>it's <b>not allowed to limit the visibility in subclass</b></li></ul><div class="separator" style="clear: both; text-align: center;"></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-y1IzFPU9_lU/VxO5tvsYvxI/AAAAAAAACbQ/91XLaHTv1usqpXMPDoRJKQJlX6EtQjI3QCLcB/s1600/visibility.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-y1IzFPU9_lU/VxO5tvsYvxI/AAAAAAAACbQ/91XLaHTv1usqpXMPDoRJKQJlX6EtQjI3QCLcB/s1600/visibility.png" /></a></div><ul style="text-align: left;"><li>if the base class has&nbsp;<b>private methods</b>, to its children they don't exist; <b>redeclaring them is not overriding</b></li><li>[my own conclusion] <b>protected does not mean </b>that subclass can access protected members of an object belonging to its supertype; it means that it inherits the protected&nbsp;members&nbsp;of its parent class,&nbsp;but <b>only in context of itself</b>; it can access the&nbsp;protected&nbsp;members&nbsp;of another object <b>only if it is in the same package</b></li></ul><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-bcI3-afheI8/VxOrNmEnVvI/AAAAAAAACbA/K_ZjV6u9YFEsEOuvpadqoZveWdbx69_sACLcB/s1600/visibility3.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img alt="" border="0" src="https://4.bp.blogspot.com/-bcI3-afheI8/VxOrNmEnVvI/AAAAAAAACbA/K_ZjV6u9YFEsEOuvpadqoZveWdbx69_sACLcB/s1600/visibility3.png" title="" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;"><span style="font-size: 12.8px;">bla() is protected in A, </span>A and B are in different packages</td></tr></tbody></table><div><ul style="text-align: left;"><li><b>static variables </b>vs <b>static methods </b>- a copy of <b>static variable </b>is copied to each class, the code of the <b>static method </b>not</li><li><b>static methods </b>are used e.g. in utility classes where they don't require object's state, or for sharing state among all instances, e.g. counter</li><li><b>static methods </b>can be accesses <b>even after a null has been assigned </b>to the object reference! <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">k=null; </span>and next <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">k.callStaticMethod()</span> - works!</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-LG_jM6NjIjA/VxvgVjAu4jI/AAAAAAAACbs/DcUT94ENv34oIaL6ep_WpBa3G5v1WnrNgCLcB/s1600/nullstatic.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-LG_jM6NjIjA/VxvgVjAu4jI/AAAAAAAACbs/DcUT94ENv34oIaL6ep_WpBa3G5v1WnrNgCLcB/s1600/nullstatic.png" /></a></div><ul style="text-align: left;"><li><b>non-static method can call a static method</b>, only vice versa is not allowed (watch out for tricky question)</li><li>a <b>constant </b>= a <b>static final variable</b></li><li><b>final </b>only means that that variable cannot be reassigned, but if it is a list for example, we can add elements (call methods)</li><li><b>static initializer</b>, is the <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">static {}</span> block, directly in the class; it <b>runs when the class is first used</b>; and <b>here (and only here) the final variables can be reassigned! </b>(but <b>not more than once</b>)</li><li><span style="background-color: #fff2cc;"><span style="background-color: white;"><b>static import </b>is declared</span><b><span style="background-color: white;">: </span><span style="background-color: yellow;">import static</span></b> <span style="background-color: #fff2cc;">java.utils.Arrays.asList</span></span><span style="background-color: white;">; in case of conflicts local have precedence; and if two imports collide there's compilation error</span></li><li>static import <b>does not import parents </b>:)</li><li><span style="background-color: #fff2cc;">Java <b>is a pass-by-value language</b>, not by reference;</span><span style="background-color: white;"> </span>it means that changing assignments inside a method has no effect outside the method</li><li><b>access modifiers </b>and <b>exception lists&nbsp;</b>are <b>irreleveant to method overloading</b>; overloading will not compile when the compiler cannot figure out the difference between 2 methods on calling,&nbsp;e.g.:</li><ul><li><b>does not compile </b>when there's:&nbsp;</li><ul><li><b>different return type</b></li><li><b>static and non static</b></li><li><b>varargs and array</b></li></ul><li><b>compiles </b>when there's&nbsp;</li><ul><li><b>int and Integer </b>- autoboxing is only done when is neccessary</li><li><b>String </b>and <b>Object</b></li><li><b>int </b>and <b>long</b>; even passing "123" to a method accepting long works</li></ul></ul><li><span style="background-color: #fff2cc;">official <b>order of calling overloaded method</b>:</span></li><ul><li><span style="background-color: #fff2cc;">exact match</span></li><li><span style="background-color: #fff2cc;">larger primitive type</span></li><li><span style="background-color: #fff2cc;">autoboxing</span></li><li><span style="background-color: #fff2cc;">varargs</span></li></ul><li>while trying to find an overload, <b>Java does max one conversion</b>, later is compilation error! E.g. calling a method accepting Long with an int argument causes a compilation error!</li><li>in constructor, when you write: <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">this.name = name; </span>it works because local variable has priority</li><li><b>default constructors </b>are actually <b>generated while compiling</b> (when applicable); the *.class file has them</li><li><span style="background-color: #fff2cc;">a manually declared constructor that looks like <b>default constructor </b>is <b>not called</b> "default constructor" anymore</span></li><li><b style="background-color: #fff2cc;">constructor chaining</b><span style="background-color: white;"> - is the technique of caling one constructor from another, adding 1 parameter each time</span></li><li><span style="background-color: white;">order of initialization:</span></li><ul><li><b>initialize superclass (</b>if present)</li><li><b>static vars </b>and <b>static initializers </b>in order they appear</li><li><b>instance variables </b>and <b>instance initializers </b>in order they appear</li><li><b>constructor</b></li></ul><li>the fact that <b>getters for boolean should begin with "is" </b>is the official JavaBeans rule for naming conventions; same goes for the rest of the name (always camel cased name of the variable, case sensitive!)</li><ul><li>for some reason <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">getNumWings(){return numberWings;}</span> was correct..</li></ul><li><b>encapsulation </b>vs <b>immutability - </b>both prevent <b>uncontrolled changes</b>; easiest way to achieve immutability is to move everything from setters to constructor (if there are mutable fields with getters, you have to defensive copy them, too)</li><li><b>lambda expression </b>is like an <b>anonymous method</b></li><li><span style="background-color: #fff2cc;"><b>a labmda expression can use</b>: instance and static variables, and method and local parameters as long as it doesn't change them</span></li><li><span style="background-color: #fff2cc;"><b>functional interface </b>- has exactly 1 method</span></li><li><span style="background-color: #fff2cc; font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">public interface Predicate&lt;T&gt;{boolean test(T t);} </span><span style="background-color: #fff2cc; font-family: inherit;">(java.util.function.*)</span></li><li><span style="background-color: #fff2cc; font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">ArrayList.removeIf(Predicate p)</span></li><li><span style="background-color: white; font-family: inherit;"><i><b>lenient </b>-&nbsp;permissive, merciful, or tolerant</i></span></li><li><span style="background-color: white; font-family: inherit;">&nbsp;"<b>package private</b>" access =&nbsp;"<b>default</b>" access !</span></li><li><span style="background-color: white; font-family: inherit;">methods can also be <b>final</b>, don't forget this</span></li><li><span style="background-color: white; font-family: inherit;"><b>what happens with instance initializer of the class </b>when </span><span style="background-color: white; font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">static void main()</span><span style="background-color: white; font-family: inherit;"> is called? nothing, they are not executed!</span></li><li><span style="background-color: white; font-family: inherit;"><b>static final </b>variables must be set!</span></li><li><span style="background-color: white; font-family: inherit;"><b>short </b>is bigger than <b>byte</b> (8)!</span></li><li><span style="background-color: white; font-family: inherit;">it is <b>okay to have a method with the same name as the class name </b>(and starting with a capital letter)</span></li><li><span style="background-color: white; font-family: inherit;">it's ok to refer to class variable in same class without the class name in front</span></li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-lGrc-aO-2ZY/VxvjyzS1l8I/AAAAAAAACb4/UQzzR8UMadQAOe54OK_EnuiV7K5GcHUagCLcB/s1600/staticreference.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/-lGrc-aO-2ZY/VxvjyzS1l8I/AAAAAAAACb4/UQzzR8UMadQAOe54OK_EnuiV7K5GcHUagCLcB/s1600/staticreference.png" /></a></div><h4 style="text-align: left;"></h4><h4 style="text-align: left;">Chapter 5 Class Design (45% correct)</h4><ul style="text-align: left;"><li>in top level classes only <b>public </b>or <b>default </b>access is allowed</li><li><b>hiding static methods </b>- when a static method is overridden, this is actually called <b>hiding</b>, not overriding ;) ("<b>static</b>"<b>&nbsp;</b>modifiers <b>must match</b>!)</li><li>class/instance <b>variables are always hidden </b>when extending&nbsp;- <b>both </b>instances exist in memory, within the child class object (and referring them <b>does not work </b>like invoking methods&nbsp;polymorphically)</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-IJim1zd-cIg/Vx6STvtYU2I/AAAAAAAACdQ/OTEQRaj6f8cEH-ueYvt_9drt_ElP59gagCLcB/s1600/hidingvars.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://1.bp.blogspot.com/-IJim1zd-cIg/Vx6STvtYU2I/AAAAAAAACdQ/OTEQRaj6f8cEH-ueYvt_9drt_ElP59gagCLcB/s1600/hidingvars.png" /></a></div><ul style="text-align: left;"><li><b>private </b>variables / static methods not being accessible in a subclass <b>is also called hiding</b>! (so yes it happens always)</li><li>Java (still) implements <b>single </b>inheritance (no inheriting from multiple classes), but <b>multiple level inheritance </b>(arbitrarily many classes in inheritance hierarchy); as exception to the single inheritance, it allows <b>implementing multiple interfaces</b></li><li>Java <b>compiler automatically inserts stuff </b>like "extends java.lang.Object" or "super();" call in constructor</li><li>you can also access fields with <b>super</b>, e.g. super.age</li><li>pay attention to the difference between <b>this </b>and <b>this()</b>, <b>super </b>and <b>super()</b></li><li>you can <b>call super class' method </b>by calling <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">SuperClassName.doSomething()</span></li><li><b>final </b>methods cannot be <b>overridden </b>or <b>hidden</b></li><li><b>exceptions </b>in implementing classes can be more narrow or <b>missing(!)</b>, but <b>not broader</b></li></ul><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-FqwWc33syhA/Vx0M1ZkLjxI/AAAAAAAACcQ/i7Dhxxvty7UWlG3GZ0rrfHlr3THZ6HcRgCLcB/s1600/exceptions.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-FqwWc33syhA/Vx0M1ZkLjxI/AAAAAAAACcQ/i7Dhxxvty7UWlG3GZ0rrfHlr3THZ6HcRgCLcB/s1600/exceptions.png" /></a></div><div><ul style="text-align: left;"><li><b>covariant return type</b> - in inheriting class the return type must be same or more narrow than in superclass' method</li><li><b>abstract class and interface cannot be marked as final </b>(of course, right..); same with <b>abstract </b>method</li><li>an <b>abstract method cannot be private</b>; same with <b>abstract class</b></li><li><b>interfaces </b>are assumed to be <b>abstract</b>, you can even specify them abstract:</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-yF2SDFMDPng/Vx6D7LsSPZI/AAAAAAAACco/MYUISr-Xb1QEHfVUgirJ1bKqAzwTsC3jACLcB/s1600/abstractInterface.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://4.bp.blogspot.com/-yF2SDFMDPng/Vx6D7LsSPZI/AAAAAAAACco/MYUISr-Xb1QEHfVUgirJ1bKqAzwTsC3jACLcB/s1600/abstractInterface.png" /></a></div><div class="separator" style="clear: both; text-align: left;"></div><ul style="text-align: left;"><li><b>interfaces </b>are assumed to have only&nbsp;<b>public </b>or <b>default </b>access</li><li><b>interface</b>'s variables are assumed to be <b>public&nbsp;static final </b>(so must be initialized, even if no <b>final </b>is&nbsp;explicitly written!)</li><li><b><b>interface</b><span style="font-weight: normal;">'s methods are assumed to be </span>public <strike>abstract</strike></b>&nbsp;<b><u>either abstract, static or default</u> </b>(since Java 8!)</li><li>on exam be careful with "<i>extending intefaces</i>" and "<i>implementing abctract classes</i>" (both wrong:P)</li><li>extending abstract classes and implementing (multiple) interfaces at the same time, what happens on <b>method clash</b>:</li><ul><li>if <b>signatures match</b>, no problem (!)</li><li>if not (and it's not an overload), <b>compilation error</b>&nbsp;:)</li><ul><li>unless, unless, <b>exactly one of them</b> is marked as <b>default</b> (Java 8)</li><li>okay, last chance :P also <b>more than one </b>can be marked as default, but then all implementing classes must override at least&nbsp;<b>all of them but one</b></li></ul></ul><li><b>default method </b>- can be defined <b>only in interface </b>and <b>has body</b>; is <b>not </b>assumed to be<b> abstract</b>,<b> nor static</b>,<b> nor final</b>, always assumed to be&nbsp;<b>public </b>though</li><ul><li>was introduced to keep <b>backward compatibility</b> in Java 8</li><li>implementing classes can override but don't have to</li><li>they <b>require </b>implementing class to be invoked (cannot invoke on the interface)</li></ul></ul><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-7FZK1PFjzCY/Vx6JrVidqlI/AAAAAAAACdA/NGhLxGYfSYg2Jl1HzUEkyBjdQKInYudkgCLcB/s1600/defaultmethod.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-7FZK1PFjzCY/Vx6JrVidqlI/AAAAAAAACdA/NGhLxGYfSYg2Jl1HzUEkyBjdQKInYudkgCLcB/s1600/defaultmethod.png" /></a></div><ul><li style="text-align: left;"><b>default method </b>can be <b>redeclared </b>as <b>abstract </b>in extending interface/implementing abstract class!</li><li style="text-align: left;"><span style="background-color: #fff2cc;"><b>static method of an interface </b>- also new in Java 8</span>&nbsp;- just like a static method, but does&nbsp;<b>not get inherited</b>! must be declared with word "<b>static</b>"; must be referred to using the&nbsp;<b>interface name </b>(even in implementing class)</li><li style="text-align: left;"><b>virtual method </b>- this is connected to plymorphism; <span style="background-color: #fff2cc;">it's a method whose implementation is not determined until runtime</span>; all non-final, non-static and non-private methods in Java are <b>virtual</b></li><li style="text-align: left;">(understanding <b>polymorphism </b>- of course, you need to know that if you create an object and assign it to reference of the type of its <b>superclass</b>, and call a method on it, <b>still the subclass' method</b> will be invoked)</li><li style="text-align: left;">this, compiles (aaaarrrgh!):</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-sGcsymt5vC8/Vx6XTrsvmLI/AAAAAAAACdg/dEWcJ0_U6tMiU_kpu-g-TeD7_SYw7sEJwCLcB/s1600/spaces.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-sGcsymt5vC8/Vx6XTrsvmLI/AAAAAAAACdg/dEWcJ0_U6tMiU_kpu-g-TeD7_SYw7sEJwCLcB/s1600/spaces.png" /></a></div><div><br /><ul style="text-align: left;"><li>pay attention to <b>missing default constructors</b> when others are present!</li><li>look, a sentence: "<i>a class implementing an interface must implement all its methods</i>" is <b>false</b>, since the implementing class could be <b>abstract </b>(fa-ce-palm)</li><ul><li>getting even better: "<i>a concrete <b>sub</b>class must implement all the methods defined in inherited interface</i>", also <b>false</b>, since it could have been a 2nd level inheritance, and maybe some class in the middle has already implemented some of the methods (ah, seriously?!)</li><li>conclustion - <b>read each answer separately</b>, don't keep the context from previous sentences you've just read.. ah, such bastards!</li></ul><li><i>"inherit an interface"</i>, <i>"override a method of an interface"&nbsp;</i>- those seem to be <b>correct </b>expressions..</li><li><b>method hiding </b>can be veery tricky:</li></ul><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-T97ph1qnON8/Vx_djIraEiI/AAAAAAAACdw/KYWtVMY_Zy4jtyhxSE9i6Nj7yVDL-zJdgCLcB/s1600/methodhiding.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/-T97ph1qnON8/Vx_djIraEiI/AAAAAAAACdw/KYWtVMY_Zy4jtyhxSE9i6Nj7yVDL-zJdgCLcB/s1600/methodhiding.png" /></a></div><div><ul style="text-align: left;"><ul><li>actually now that I think about it, it's pretty logical, as Bird reference has no chance of knowing that Pelican has declared some method, as there is no link between the two fly() methods (as the Bird one is private)&nbsp;</li></ul></ul></div></div><h4 style="text-align: left;">Chapter 6 Exceptions (80% correct, 16/20)</h4><div><ul style="text-align: left;"><li><span style="background-color: #fff2cc;"><b>Errors </b>- they are the other subclass of <b>Throwable</b>, and are meant to express something that went <b>very wrong</b>; <b>JVM </b>throws them; you're <b>not supposed </b>to catch them, as anyway you won't be able to fix them;</span></li><li>RuntimeExceptions you may catch</li><li>you <b>cannot omit braces </b>with <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">try-catch</span>, like you can with <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">if </span>and with <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">when</span></li><li><b>catch </b>and <b>finally </b>blocks have to be <b>in the right order</b>; <b>at least one </b>must be present</li><li>finally runs <b>always</b>, <b>except </b>when <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">System.exit(int code)</span>&nbsp;is called!</li><li>catching a subtype of exception that was caught above <b>does not compile</b></li><li><b>at most one catch block runs (first one matching) - remember about it when you read the code, it's easy to forget!</b></li><li><b>exception thrown from inside finally block masks the exception thrown in the catch block! </b>the previous exception is as if it was not thrown at all</li><li><span style="background-color: #fff2cc;">RuntimeException examples:</span></li><ul><li><span style="background-color: #fff2cc;"><b>ArithmeticException</b></span></li><li><span style="background-color: #fff2cc;"><b>ArrayIndexOutOfBoundsException</b></span></li><li><span style="background-color: #fff2cc;"><b>ClassCastException</b></span></li><li><span style="background-color: #fff2cc;"><b>IllegalArgumentException</b></span></li><ul><li><span style="background-color: #fff2cc;"><b>NullPointerException </b>(extends IllegalArgumentException)</span></li></ul><li><span style="background-color: #fff2cc;"><b>NumberFormatException</b></span></li></ul><li><span style="background-color: #fff2cc;">checked exception examples:</span></li><ul><li><span style="background-color: #fff2cc;"><b>IOException</b></span></li><ul><li><span style="background-color: #fff2cc;"><b>FileNotFoundException </b>(extends IOException)</span></li></ul></ul><li><span style="background-color: #fff2cc;">error examples:</span></li><ul><li><span style="background-color: #fff2cc;"><b>ExceptionInitializerError </b>- when static initializer block in a class throws an exception</span></li><li><span style="background-color: #fff2cc;"><b>StackOverflowError</b></span></li><li><span style="background-color: #fff2cc;"><b>NoClassDefFoundError</b></span></li></ul><li>overriding/implementing method<b> can declare less checked exceptions</b>, but not more; in case of runtime exceptions anything is compiling</li><li>System.out.println(e); has same effect as<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"> System.out.println(e.getClass().getName()+": "+e.getMessage());</span></li></ul></div><div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="https://3.bp.blogspot.com/-51_K26pPQE8/V0bnCvpqsOI/AAAAAAAACeU/MYxSCGROJKAnGVElf91G_YVVZ6kGJ49lgCLcB/s1600/exceptionConstrs.png" /></div><div class="separator" style="clear: both; text-align: center;"></div><ul><ul><li style="text-align: left;">all of these exceptions have default constructor, yaay!</li></ul><li style="text-align: left;"><b>Errors are allowed to be handled or declared </b>- this sentence is true; yes, they should not be, but they are allowed to!</li></ul><br /><b><br /></b></div><br /><div><br /></div><div><b><br /></b></div></div><ul style="text-align: left;"><ul></ul></ul></div></div></div></div></div></div></div>